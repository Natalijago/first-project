# Шпаргалка по гиту
 ## Навигация в консоли
 * `pwd` покажи, в какой я папке;
 * `ls` покажи файлы и папки в текущей папке;
 * `ls -a`покажи также скрытые файлы и папки, названия которых начинаются с символа `.`;
 * `cd folder-name` перейди в папку
 * `cd folder-name\folder1` перейди в папку folder1, которая находится в папке folder-name;
 * `cd ..`перейди на уровень выше, в родительскую папку;
 * `cd ~`перейди в домашнюю директорию;
 * `cd /`перейди в корневую директорию.

 ## Работа с Git

 * `git`сделать папку репозиторием
 * `rm -rf .git` разгитить папку
 * `git status` проверить состояние репозитория
 * `git add` подготовить файлы к сохранению
 * `git commit` выполнить коммит
 * `git log` посмтреть историю коммитов
 
 ## Генерация SSH-ключа
 * `$ ssh-keygen -t ed25519 -C "электронная почта, к которой привязан ваш аккаунт на GitHub"`
 * `ls -a ~/.ssh` проверяем действительно ли ключи сгенерировались
* `clip < ~/.ssh/id_ed25519.pub` скопировать в буфер обмена
* `$ ssh -T git@github.com` проверяем правильность ключа

## Синхронизация Git и GitHub
* `git remote add` привязать удаленный репозиторий к локальному
* `git remote -v` убедиться, что репозитории связаны
* `git push` отправить изменения на удаленный репозиторий

## Файл README.md
Как правило, в `README.md` проекта можно найти следующую информацию:
1. Название проекта и его краткое описание: кем создан, для чего, какие решает задачи и какие закрывает проблемы.
2. Технологии, которые применяются в проекте. В чём его отличие от аналогичных.
3. Документация проекта — подробная инструкция о том, что представляет собой проект.
4. Планы проекта, если они есть.

Разметка файла README осущствляется с помощью [Markdown](https://www.markdownguide.org/cheat-sheet/)

## Хеш — идентификатор коммита
**Хэширование** - Обычно хеш — это короткая (40 символов в случае SHA-1) строка, которая состоит из цифр 0—9 и латинских букв A—F(неважно, заглавных или строчных). Она обладает следующими важными свойствами:
* если хеш получить дважды для одного и того же набора входных данных, то результат будет гарантированно одинаковый;
* если хоть что-то в исходных данных поменяется (хотя бы один символ), то хеш тоже изменится (причём сильно).

* Git преобразует информацию о коммитах с помощью алгоритма SHA-1 и для каждого из них рассчитывает уникальный идентификатор — хеш.
* Хеш — основной идентификатор коммита и позволяет узнать его автора, дату и содержимое закоммиченных файлов.
* Все хеши, а также таблицу соответствий хеш → информация о коммите Git хранит в папке `.git`.

## Исследование лога
`git log` - после вызова, показывается список коммитов. Элемнты из которых состоит описание:
1. строка из цифр и латинских букв после слова commit — это хеш коммита;
2. Author — имя автора и его электронная почта;
3. Date — дата и время создания коммита;
4. в конце находится сообщение коммита.

`git log --oneline` - получить сокращенный лог.
В сокращённом логе выводятся сокращённые хеши — их можно использовать точно так же, как и полные.

## Файл HEAD
Файл `HEAD` — один из служебных файлов папки .git. Он указывает на коммит, который сделан последним (то есть на самый новый).
* Внутри `HEAD` — ссылка на служебный файл: *refs/heads/master* (или *refs/heads/main* в зависимости от названия ветки). Если заглянуть в этот файл, можно увидеть хеш последнего коммита.
* Вместо хеша последнего коммита можно написать слово HEAD — Git вас поймёт.

## Статусы файлов в Git
**Статусы:**
1. *untracked* (англ. «неотслеживаемый»). У untracked-файла нет предыдущих версий, зафиксированных в коммитах или через команду git add.
2. *staged* (англ. «подготовленный»). После выполнения команды git add файл попадает в staging area, то есть в список файлов, которые войдут в коммит. В этот момент файл находится в состоянии staged.
3. *tracked* (англ. «отслеживаемый»). Состояние tracked — это противоположность untracked. Оно довольно широкое по смыслу: в него попадают файлы, которые уже были зафиксированы с помощью git commit, а также файлы, которые были добавлены в staging area командой git add. То есть все файлы, в которых Git так или иначе отслеживает изменения
4. *modified* (англ. «изменённый»). Состояние modified означает, что Git сравнил содержимое файла с последней сохранённой версией и нашёл отличия. Например, файл был закоммичен и после этого изменён

``` mermaid
graph TD;
    A[untracked\n(неотслеживаемый)] -->|git add| B[modified\n(изменённый)];
    B -->|git add| C[staged\n(в списке на коммит) + tracked\n(отслеживаемый)];
    C -->|git commit| D[tracked\n(отслеживаемый)];
    B <--|Изменения| A;
    B -->|Изменения| C;

```
## Оформление сообщений к коммитам
Есть общие рекомендации по тому, как правильно составить сообщение. Оно должно быть:
* относительно коротким, чтобы его было легко прочитать;
* информативным; 
* все сообщения оформлены в одном стиле.

**Корпоративный стиль оформления:**
В корпоративном стиле в начале сообщения обычно указывают Jira-ID, а после — текст сообщения. Пример:
```bash
git commit -m "LGS-239: Дополнить список пасхалок новыми числами"
```
**Conventional Commits:**
Conventional Commits предлагает такой формат коммита: `<type>: <сообщение>`. Первая часть `type` — это тип изменений. Таких типов достаточно много. Вот два примера:
* `feat` (сокращение от англ. feature) — для новой функциональности;
* `fix` (от англ. «исправить», «устранить») — для исправленных ошибок.
Пример:
```bash
git commit -m "feat: добавить подсчёт суммы заказов за неделю"
```
**GitHub-стиль:**
GitHub можно использовать не только для хранения файлов проекта, но и для ведения списка задач (англ. issue) этого проекта. Если коммит «закрывает» или «решает» какую-то задачу, то в его сообщении удобно указывать ссылку на неё. Для этого в любом месте сообщения нужно указать #<номер задачи>. Например, вот так:
```bash
git commit -m "Исправить #334, добавить график температуры"
```
В таком случае GitHub свяжет коммит и задачу.
> [!NOTE]
> Для сообщений на русском языке часто рекомендуют использовать инфинитивы. Например: Добавить тесты для PipkaService, Исправить ошибку #123 и так далее.
>
> Для сообщений на английском рекомендуется использовать повелительное наклонение (англ. imperative). Например: Use library mega_lib_300, Fix exit button и так далее.
> Эти рекомендации сложились исторически, и им следуют многие проекты.
